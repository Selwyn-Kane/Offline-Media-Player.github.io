<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé§ Automatic Lyrics Fetcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
        }
        
        .instructions {
            background: rgba(40, 167, 69, 0.1);
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .instructions h2 {
            color: #28a745;
            margin-bottom: 15px;
        }
        
        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.5);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        button.success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }
        
        #progress-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        #progress-section.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #222;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545 0%, #ff7788 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #dc3545;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }
        
        #results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .result-item.success {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }
        
        .result-item.not-found {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        .result-item.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .result-detail {
            font-size: 0.9em;
            color: #aaa;
        }
        
        #results::-webkit-scrollbar {
            width: 8px;
        }
        
        #results::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        #results::-webkit-scrollbar-thumb {
            background: #dc3545;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Automatic Lyrics Fetcher</h1>
        
        <div class="instructions">
            <h2>üìñ How to Use</h2>
            <ol>
                <li>Click <strong>"Select Music Folder"</strong> and choose your music folder</li>
                <li>The tool will scan all MP3 files and read their metadata</li>
                <li>Click <strong>"Fetch Lyrics for All Songs"</strong> to automatically download synced lyrics</li>
                <li>VTT files will be saved with matching filenames in a ZIP file</li>
                <li>Extract the ZIP and place the VTT files in your music folder</li>
                <li>Reload your music player - lyrics will appear automatically!</li>
            </ol>
        </div>
        
        <div class="button-group">
            <button id="select-folder-btn">üìÅ Select Music Folder</button>
            <button id="fetch-lyrics-btn" disabled>üé§ Fetch Lyrics for All Songs</button>
            <button id="download-zip-btn" disabled style="display: none;">üíæ Download VTT Files (ZIP)</button>
        </div>
        
        <div id="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill">0%</div>
            </div>
            <div id="status-text" style="text-align: center; margin-bottom: 15px;">Ready...</div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="stat-total">0</div>
                    <div class="stat-label">Total Songs</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-found" style="color: #28a745;">0</div>
                    <div class="stat-label">Lyrics Found</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-not-found" style="color: #ffc107;">0</div>
                    <div class="stat-label">Not Found</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-errors" style="color: #dc3545;">0</div>
                    <div class="stat-label">Errors</div>
                </div>
            </div>
        </div>
        
        <div id="results"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script>
        let musicFiles = [];
        let vttFiles = {};
        let stats = { total: 0, found: 0, notFound: 0, errors: 0 };
        
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const fetchLyricsBtn = document.getElementById('fetch-lyrics-btn');
        const downloadZipBtn = document.getElementById('download-zip-btn');
        const progressSection = document.getElementById('progress-section');
        const progressFill = document.getElementById('progress-fill');
        const statusText = document.getElementById('status-text');
        const resultsDiv = document.getElementById('results');
        
        // Select music folder
        selectFolderBtn.onclick = async () => {
            try {
                const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
                
                musicFiles = [];
                statusText.textContent = 'Scanning folder...';
                progressSection.classList.add('show');
                
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        if (file.name.match(/\.(mp3|m4a|flac)$/i)) {
                            musicFiles.push(file);
                        }
                    }
                }
                
                stats.total = musicFiles.length;
                updateStats();
                
                addResult(`Found ${musicFiles.length} audio files`, 'success');
                statusText.textContent = `Ready to fetch lyrics for ${musicFiles.length} songs`;
                fetchLyricsBtn.disabled = false;
                selectFolderBtn.textContent = `‚úÖ ${musicFiles.length} Songs Loaded`;
                selectFolderBtn.classList.add('success');
                
            } catch (err) {
                addResult(`Error: ${err.message}`, 'error');
            }
        };
        
        // Fetch lyrics for all songs
        fetchLyricsBtn.onclick = async () => {
            fetchLyricsBtn.disabled = true;
            selectFolderBtn.disabled = true;
            resultsDiv.innerHTML = '';
            stats = { total: musicFiles.length, found: 0, notFound: 0, errors: 0 };
            vttFiles = {};
            
            for (let i = 0; i < musicFiles.length; i++) {
                const file = musicFiles[i];
                const progress = ((i + 1) / musicFiles.length) * 100;
                
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${Math.round(progress)}%`;
                statusText.textContent = `Processing: ${file.name} (${i + 1}/${musicFiles.length})`;
                
                try {
                    // Extract metadata
                    const metadata = await extractMetadata(file);
                    const artist = metadata.artist || 'Unknown';
                    const title = metadata.title || file.name.replace(/\.[^/.]+$/, '');
                    
                    // Query LRCLIB
                    const lyrics = await fetchLyricsFromLRCLIB(artist, title);
                    
                    if (lyrics) {
                        // Convert to VTT
                        const vttContent = convertLRCtoVTT(lyrics);
                        const vttFilename = file.name.replace(/\.[^/.]+$/, '.vtt');
                        vttFiles[vttFilename] = vttContent;
                        
                        stats.found++;
                        addResult(`‚úÖ ${file.name}: Found lyrics (${lyrics.length} lines)`, 'success');
                    } else {
                        stats.notFound++;
                        addResult(`‚ö†Ô∏è ${file.name}: No lyrics found for "${title}" by ${artist}`, 'not-found');
                    }
                } catch (err) {
                    stats.errors++;
                    addResult(`‚ùå ${file.name}: ${err.message}`, 'error');
                }
                
                updateStats();
                
                // Small delay to avoid rate limiting
                await sleep(300);
            }
            
            statusText.textContent = `‚úÖ Complete! Found lyrics for ${stats.found}/${stats.total} songs`;
            fetchLyricsBtn.textContent = '‚úÖ Fetch Complete';
            
            if (Object.keys(vttFiles).length > 0) {
                downloadZipBtn.style.display = 'inline-block';
                downloadZipBtn.disabled = false;
            }
        };
        
        // Download ZIP
        downloadZipBtn.onclick = async () => {
            const zip = new JSZip();
            
            for (const [filename, content] of Object.entries(vttFiles)) {
                zip.file(filename, content);
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lyrics_${Date.now()}.zip`;
            a.click();
            URL.revokeObjectURL(url);
            
            addResult(`üì¶ Downloaded ${Object.keys(vttFiles).length} VTT files as ZIP`, 'success');
        };
        
        // Extract metadata using jsmediatags
        function extractMetadata(file) {
            return new Promise((resolve) => {
                jsmediatags.read(file, {
                    onSuccess: (tag) => {
                        resolve({
                            title: tag.tags.title,
                            artist: tag.tags.artist,
                            album: tag.tags.album
                        });
                    },
                    onError: () => {
                        resolve({ title: null, artist: null, album: null });
                    }
                });
            });
        }
        
        // Fetch lyrics from LRCLIB API
        async function fetchLyricsFromLRCLIB(artist, title) {
            try {
                const params = new URLSearchParams({
                    artist_name: artist,
                    track_name: title
                });
                
                const response = await fetch(`https://lrclib.net/api/get?${params}`);
                
                if (!response.ok) {
                    return null;
                }
                
                const data = await response.json();
                
                // Use syncedLyrics if available, otherwise plain lyrics
                if (data.syncedLyrics) {
                    return parseLRC(data.syncedLyrics);
                } else if (data.plainLyrics) {
                    // Create fake timestamps for plain lyrics
                    const lines = data.plainLyrics.split('\n');
                    return lines.map((text, i) => ({
                        time: i * 3, // 3 seconds per line
                        text: text.trim()
                    })).filter(l => l.text);
                }
                
                return null;
            } catch (err) {
                throw new Error(`API error: ${err.message}`);
            }
        }
        
        // Parse LRC format to array of {time, text}
        function parseLRC(lrcContent) {
            const lines = lrcContent.split('\n');
            const lyrics = [];
            
            for (const line of lines) {
                const match = line.match(/\[(\d+):(\d+)\.(\d+)\](.*)/);
                if (match) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const centiseconds = parseInt(match[3]);
                    const text = match[4].trim();
                    
                    const time = minutes * 60 + seconds + centiseconds / 100;
                    lyrics.push({ time, text });
                }
            }
            
            return lyrics;
        }
        
        // Convert LRC format to VTT format
        function convertLRCtoVTT(lyrics) {
            let vtt = 'WEBVTT\n\n';
            
            for (let i = 0; i < lyrics.length; i++) {
                const current = lyrics[i];
                const next = lyrics[i + 1];
                
                const startTime = formatVTTTime(current.time);
                const endTime = next ? formatVTTTime(next.time) : formatVTTTime(current.time + 5);
                
                vtt += `${startTime} --> ${endTime}\n`;
                vtt += `${current.text}\n\n`;
            }
            
            return vtt;
        }
        
        // Format time as VTT timestamp (HH:MM:SS.mmm)
        function formatVTTTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const millis = Math.floor((seconds % 1) * 1000);
            
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
        }
        
        // Add result to log
        function addResult(message, type) {
            const item = document.createElement('div');
            item.className = `result-item ${type}`;
            item.innerHTML = `<div class="result-title">${message}</div>`;
            resultsDiv.appendChild(item);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('stat-total').textContent = stats.total;
            document.getElementById('stat-found').textContent = stats.found;
            document.getElementById('stat-not-found').textContent = stats.notFound;
            document.getElementById('stat-errors').textContent = stats.errors;
        }
        
        // Sleep utility
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>