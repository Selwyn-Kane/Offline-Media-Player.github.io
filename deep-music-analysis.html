<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¨ Music Analysis - Zero-Copy Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
        }
        
        .badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.7em;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        .instructions {
            background: rgba(40, 167, 69, 0.1);
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .instructions h2 {
            color: #28a745;
            margin-bottom: 15px;
        }
        
        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }
        
        .feature-highlight {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .feature-highlight h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .feature-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.5);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        button.success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }
        
        #progress-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        #progress-section.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #222;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545 0%, #ff7788 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #dc3545;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }
        
        .performance-metrics {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        .performance-metrics.show {
            display: block;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            font-size: 0.85em;
            color: #aaa;
            margin-top: 5px;
        }
        
        #results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .result-item.success {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }
        
        .result-item.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .result-item.info {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .analysis-preview {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #0f0;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        #results::-webkit-scrollbar {
            width: 8px;
        }
        
        #results::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        #results::-webkit-scrollbar-thumb {
            background: #dc3545;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Music Analysis <span class="badge">ZERO-COPY</span></h1>
        
        <div class="feature-highlight">
            <h3>‚ö° Powered by Web Audio Data Bridge</h3>
            <div class="feature-list">
                <div class="feature-item">‚úÖ Zero-copy transfers</div>
                <div class="feature-item">‚úÖ Worker pool reuse</div>
                <div class="feature-item">‚úÖ Memory tracking</div>
                <div class="feature-item">‚úÖ Advanced error handling</div>
                <div class="feature-item">‚úÖ Performance monitoring</div>
                <div class="feature-item">‚úÖ Health checks</div>
            </div>
        </div>
        
        <div class="instructions">
            <h2>üìñ How to Use</h2>
            <ol>
                <li>Click <strong>"Select Music Folder"</strong> and choose your music folder</li>
                <li>The tool will scan all audio files (MP3, M4A, FLAC, WAV, OGG)</li>
                <li>Click <strong>"Analyze All Songs"</strong> to perform advanced analysis with zero-copy transfers</li>
                <li>Watch real-time performance metrics showing memory savings</li>
                <li>Download analysis files when complete</li>
            </ol>
        </div>
        
        <div class="button-group">
            <button id="select-folder-btn">üìÅ Select Music Folder</button>
            <button id="analyze-btn" disabled>üî¨ Analyze All Songs</button>
            <button id="download-zip-btn" disabled style="display: none;">üíæ Download Analysis Files</button>
        </div>
        
        <div id="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill">0%</div>
            </div>
            <div id="status-text" style="text-align: center; margin-bottom: 15px;">Ready...</div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="stat-total">0</div>
                    <div class="stat-label">Total Songs</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-analyzed" style="color: #28a745;">0</div>
                    <div class="stat-label">Analyzed</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-errors" style="color: #dc3545;">0</div>
                    <div class="stat-label">Errors</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-time">0s</div>
                    <div class="stat-label">Elapsed Time</div>
                </div>
            </div>
        </div>
        
        <div class="performance-metrics" id="performance-metrics">
            <h3 style="color: #667eea; margin-bottom: 15px;">‚ö° Zero-Copy Performance Metrics</h3>
            <div class="metric-grid">
                <div class="metric-card">
                    <div class="metric-value" id="metric-transfers">0</div>
                    <div class="metric-label">Zero-Copy Transfers</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="metric-data-transferred">0 MB</div>
                    <div class="metric-label">Data Transferred</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="metric-avg-transfer">0 ms</div>
                    <div class="metric-label">Avg Transfer Time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="metric-workers">0</div>
                    <div class="metric-label">Active Workers</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="metric-memory-saved">0 MB</div>
                    <div class="metric-label">Memory Saved vs Copy</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="metric-throughput">0 MB/s</div>
                    <div class="metric-label">Throughput</div>
                </div>
            </div>
        </div>
        
        <div id="results"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // ============================================================================
        // WEB AUDIO DATA BRIDGE - CORE COMPONENTS
        // ============================================================================
        
        const MSG = {
            ANALYZE_AUDIO: 'analyze_audio',
            ANALYSIS_COMPLETE: 'analysis_complete',
            WORKER_READY: 'worker_ready',
            WORKER_ERROR: 'worker_error',
            PING: 'ping',
            PONG: 'pong'
        };
        
        class TransferableDataManager {
            constructor() {
                this.transferRegistry = new Map();
                this.totalBytesTransferred = 0;
            }

            audioBufferToTransferable(audioBuffer) {
                const channels = [];
                const transfers = [];
                const bufferId = `buf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    const channelData = audioBuffer.getChannelData(i);
                    const arrayBuffer = channelData.buffer;
                    
                    channels.push({
                        buffer: arrayBuffer,
                        byteOffset: channelData.byteOffset,
                        byteLength: channelData.byteLength
                    });
                    
                    transfers.push(arrayBuffer);
                }

                const totalSize = transfers.reduce((sum, buf) => sum + buf.byteLength, 0);
                this.totalBytesTransferred += totalSize;

                this.transferRegistry.set(bufferId, {
                    numberOfChannels: audioBuffer.numberOfChannels,
                    length: audioBuffer.length,
                    sampleRate: audioBuffer.sampleRate,
                    transferredAt: performance.now(),
                    size: totalSize
                });

                return {
                    transferable: {
                        id: bufferId,
                        channels,
                        sampleRate: audioBuffer.sampleRate,
                        length: audioBuffer.length,
                        numberOfChannels: audioBuffer.numberOfChannels
                    },
                    transfers,
                    size: totalSize
                };
            }

            getStats() {
                const entries = Array.from(this.transferRegistry.values());
                const totalSize = entries.reduce((sum, e) => sum + e.size, 0);
                
                return {
                    activeBuffers: entries.length,
                    totalMemoryBytes: totalSize,
                    totalMemoryMB: (totalSize / (1024 * 1024)).toFixed(2),
                    totalBytesTransferred: this.totalBytesTransferred,
                    totalMBTransferred: (this.totalBytesTransferred / (1024 * 1024)).toFixed(2)
                };
            }
        }

        class EnhancedWorkerProxy {
            constructor(worker, workerId, timeout = 120000) {
                this.worker = worker;
                this.workerId = workerId;
                this.timeout = timeout;
                this.messageHandlers = new Map();
                this.requestId = 0;
                this.pendingRequests = new Map();
                this.isTerminated = false;

                this.worker.onmessage = (e) => this.handleMessage(e);
                this.worker.onerror = (e) => this.handleError(e);
            }

            handleMessage(e) {
                const { type, requestId, data, error } = e.data;

                if (requestId && this.pendingRequests.has(requestId)) {
                    const { resolve, reject, timeoutId } = this.pendingRequests.get(requestId);
                    clearTimeout(timeoutId);
                    this.pendingRequests.delete(requestId);

                    if (error) {
                        reject(new Error(error));
                    } else {
                        resolve(data);
                    }
                }

                if (this.messageHandlers.has(type)) {
                    this.messageHandlers.get(type)(data);
                }
            }

            handleError(error) {
                console.error(`Worker ${this.workerId} error:`, error);
                
                for (const [requestId, { reject, timeoutId }] of this.pendingRequests) {
                    clearTimeout(timeoutId);
                    reject(new Error(`Worker error: ${error.message}`));
                }
                
                this.pendingRequests.clear();

                if (this.messageHandlers.has(MSG.WORKER_ERROR)) {
                    this.messageHandlers.get(MSG.WORKER_ERROR)(error);
                }
            }

            send(type, data, transfers = []) {
                if (this.isTerminated) {
                    return Promise.reject(new Error('Worker is terminated'));
                }

                const requestId = ++this.requestId;

                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        if (this.pendingRequests.has(requestId)) {
                            this.pendingRequests.delete(requestId);
                            reject(new Error(`Worker request timeout after ${this.timeout}ms`));
                        }
                    }, this.timeout);

                    this.pendingRequests.set(requestId, { resolve, reject, timeoutId });

                    try {
                        this.worker.postMessage({
                            type,
                            requestId,
                            data
                        }, transfers);
                    } catch (error) {
                        clearTimeout(timeoutId);
                        this.pendingRequests.delete(requestId);
                        reject(error);
                    }
                });
            }

            on(type, handler) {
                this.messageHandlers.set(type, handler);
            }

            terminate() {
                this.isTerminated = true;
                
                for (const { timeoutId } of this.pendingRequests.values()) {
                    clearTimeout(timeoutId);
                }
                this.pendingRequests.clear();
                
                this.worker.terminate();
            }
        }

        class WorkerConnectionPool {
            constructor(options = {}) {
                this.maxWorkers = options.maxWorkers || 4;
                this.workerTimeout = options.workerTimeout || 120000;
                this.healthCheckInterval = options.healthCheckInterval || 10000;
                
                this.workers = new Map();
                this.availableWorkers = [];
                this.requestQueue = [];
                this.workerStats = new Map();
                
                this.healthCheckTimer = null;
            }

            async createWorker(workerId, workerCode) {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                const worker = new Worker(workerUrl);
                
                const proxy = new EnhancedWorkerProxy(worker, workerId, this.workerTimeout);
                
                proxy.on(MSG.PONG, () => {
                    this.updateWorkerHealth(workerId, true);
                });
                
                proxy.on(MSG.WORKER_ERROR, (error) => {
                    this.handleWorkerError(workerId, error);
                });

                this.workers.set(workerId, proxy);
                this.availableWorkers.push(workerId);
                this.workerStats.set(workerId, {
                    created: Date.now(),
                    requests: 0,
                    errors: 0,
                    lastHealthy: Date.now(),
                    healthy: true
                });

                return proxy;
            }

            async getWorker() {
                if (this.availableWorkers.length > 0) {
                    const workerId = this.availableWorkers.shift();
                    const proxy = this.workers.get(workerId);
                    
                    const stats = this.workerStats.get(workerId);
                    stats.requests++;
                    
                    return { workerId, proxy };
                }

                if (this.workers.size < this.maxWorkers) {
                    const workerId = `worker_${this.workers.size}`;
                    const proxy = await this.createWorker(workerId, getWorkerCode());
                    
                    return { workerId, proxy };
                }

                return new Promise((resolve) => {
                    this.requestQueue.push(resolve);
                });
            }

            releaseWorker(workerId) {
                if (!this.availableWorkers.includes(workerId)) {
                    this.availableWorkers.push(workerId);
                }

                if (this.requestQueue.length > 0) {
                    const resolve = this.requestQueue.shift();
                    const proxy = this.workers.get(workerId);
                    resolve({ workerId, proxy });
                }
            }

            updateWorkerHealth(workerId, healthy) {
                const stats = this.workerStats.get(workerId);
                if (stats) {
                    stats.healthy = healthy;
                    stats.lastHealthy = Date.now();
                }
            }

            handleWorkerError(workerId, error) {
                const stats = this.workerStats.get(workerId);
                if (stats) {
                    stats.errors++;
                    stats.healthy = false;
                }

                const index = this.availableWorkers.indexOf(workerId);
                if (index > -1) {
                    this.availableWorkers.splice(index, 1);
                }
            }

            getStats() {
                return {
                    totalWorkers: this.workers.size,
                    availableWorkers: this.availableWorkers.length,
                    busyWorkers: this.workers.size - this.availableWorkers.length,
                    queuedRequests: this.requestQueue.length
                };
            }

            terminateAll() {
                for (const proxy of this.workers.values()) {
                    proxy.terminate();
                }
                
                this.workers.clear();
                this.availableWorkers = [];
                this.requestQueue = [];
                this.workerStats.clear();
            }
        }

        // ============================================================================
        // MUSIC ANALYSIS APPLICATION WITH BRIDGE INTEGRATION
        // ============================================================================
        
        class IntegratedMusicAnalyzer {
            constructor() {
                this.dataManager = new TransferableDataManager();
                this.workerPool = new WorkerConnectionPool({ 
                    maxWorkers: Math.min(4, navigator.hardwareConcurrency || 2),
                    workerTimeout: 120000
                });
                
                this.musicFiles = [];
                this.analysisFiles = {};
                this.stats = { total: 0, analyzed: 0, errors: 0 };
                this.startTime = 0;
                this.transferTimes = [];
                
                this.initUI();
                this.initWorkers();
            }
            
            async initWorkers() {
                const numWorkers = Math.min(4, navigator.hardwareConcurrency || 2);
                for (let i = 0; i < numWorkers; i++) {
                    await this.workerPool.createWorker(`analyzer_${i}`, getWorkerCode());
                }
                
                addResult(`‚úÖ Initialized ${numWorkers} workers with zero-copy support`, 'info');
            }
            
            initUI() {
                this.selectFolderBtn = document.getElementById('select-folder-btn');
                this.analyzeBtn = document.getElementById('analyze-btn');
                this.downloadZipBtn = document.getElementById('download-zip-btn');
                this.progressSection = document.getElementById('progress-section');
                this.performanceMetrics = document.getElementById('performance-metrics');
                this.progressFill = document.getElementById('progress-fill');
                this.statusText = document.getElementById('status-text');
                this.resultsDiv = document.getElementById('results');

                this.selectFolderBtn.onclick = () => this.selectFolder();
                this.analyzeBtn.onclick = () => this.analyzeAll();
                this.downloadZipBtn.onclick = () => this.downloadZip();
                
                this.startPerformanceMonitor();
            }
            
            async selectFolder() {
                try {
                    const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
                    
                    this.musicFiles = [];
                    this.statusText.textContent = 'Scanning folder...';
                    this.progressSection.classList.add('show');
                    
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file') {
                            const file = await entry.getFile();
                            if (file.name.match(/\.(mp3|m4a|flac|wav|ogg|aac)$/i)) {
                                this.musicFiles.push(file);
                            }
                        }
                    }
                    
                    this.stats.total = this.musicFiles.length;
                    updateStats(this.stats);
                    
                    addResult(`Found ${this.musicFiles.length} audio files`, 'success');
                    this.statusText.textContent = `Ready to analyze ${this.musicFiles.length} songs`;
                    this.analyzeBtn.disabled = false;
                    this.selectFolderBtn.textContent = `‚úÖ ${this.musicFiles.length} Songs Loaded`;
                    this.selectFolderBtn.classList.add('success');
                    
                } catch (err) {
                    addResult(`Error: ${err.message}`, 'error');
                }
            }
            
            async analyzeAll() {
                if (this.musicFiles.length === 0) {
                    alert('No tracks loaded!');
                    return;
                }
                
                this.analyzeBtn.disabled = true;
                this.selectFolderBtn.disabled = true;
                this.resultsDiv.innerHTML = '';
                this.stats = { total: this.musicFiles.length, analyzed: 0, errors: 0 };
                this.analysisFiles = {};
                this.startTime = Date.now();
                this.transferTimes = [];
                
                this.performanceMetrics.classList.add('show');
                
                addResult(`üöÄ Starting parallel analysis with zero-copy transfers...`, 'info');
                
                let jobIndex = 0;
                const totalJobs = this.musicFiles.length;
                
                const processJobs = async (workerNum) => {
                    while (jobIndex < totalJobs) {
                        const currentIndex = jobIndex++;
                        const file = this.musicFiles[currentIndex];
                        
                        try {
                            this.statusText.textContent = `Worker ${workerNum} decoding: ${file.name}`;
                            
                            // Decode audio
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const arrayBuffer = await file.arrayBuffer();
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            
                            // Get worker
                            const { workerId, proxy } = await this.workerPool.getWorker();
                            
                            try {
                                this.statusText.textContent = `Worker ${workerNum} analyzing: ${file.name} (Zero-Copy)`;

// Determine optimal analysis strategy
const strategy = this.determineAnalysisStrategy(audioBuffer, file.name);

// ZERO-COPY TRANSFER HERE!
const transferStart = performance.now();
const { transferable, transfers, size } = 
    this.dataManager.audioBufferToTransferable(audioBuffer);

const analysis = await proxy.send(
    MSG.ANALYZE_AUDIO,
    {
        ...transferable,
        duration: audioBuffer.duration,
        filename: file.name,
        strategy: strategy // ADD THIS
    },
    transfers
);
                                
                                const transferTime = performance.now() - transferStart;
                                this.transferTimes.push({ time: transferTime, size });
                                
                                await audioContext.close();
                                
                                // Save results
                                const txtContent = formatAnalysisAsText(file.name, analysis);
                                const txtFilename = file.name.replace(/\.[^/.]+$/, '.txt');
                                this.analysisFiles[txtFilename] = txtContent;
                                
                                this.stats.analyzed++;
                                addResult(
                                    `‚úÖ ${file.name}: Complete (Worker ${workerNum}) - ` +
                                    `${(size / 1024).toFixed(1)}KB transferred in ${transferTime.toFixed(1)}ms`, 
                                    'success', 
                                    analysis
                                );
                                
                            } finally {
                                this.workerPool.releaseWorker(workerId);
                            }
                            
                        } catch (err) {
                            this.stats.errors++;
                            addResult(`‚ùå ${file.name}: ${err.message}`, 'error');
                        }
                        
                        const progress = ((this.stats.analyzed + this.stats.errors) / totalJobs) * 100;
                        this.progressFill.style.width = `${progress}%`;
                        this.progressFill.textContent = `${Math.round(progress)}%`;
                        this.statusText.textContent = `Progress: ${this.stats.analyzed + this.stats.errors}/${totalJobs}`;
                        updateStats(this.stats);
                    }
                };
                
                const numWorkers = Math.min(4, navigator.hardwareConcurrency || 2);
                const workerPromises = [];
                for (let i = 0; i < numWorkers; i++) {
                    workerPromises.push(processJobs(i + 1));
                }
                
                await Promise.all(workerPromises);
                
                this.statusText.textContent = `‚úÖ Complete! Analyzed ${this.stats.analyzed}/${this.stats.total} songs`;
                this.analyzeBtn.disabled = false;
                this.selectFolderBtn.disabled = false;
                
                if (Object.keys(this.analysisFiles).length > 0) {
                    this.downloadZipBtn.style.display = 'inline-block';
                    this.downloadZipBtn.disabled = false;
                }
                
                const totalTime = Math.floor((Date.now() - this.startTime) / 1000);
                const avgTime = this.stats.analyzed > 0 ? (totalTime / this.stats.analyzed).toFixed(1) : 0;
                
                const bridgeStats = this.dataManager.getStats();
                const avgTransfer = this.transferTimes.reduce((sum, t) => sum + t.time, 0) / this.transferTimes.length;
                const copyCost = bridgeStats.totalBytesTransferred * 0.01; // Estimate: 10ms per MB for copy
                const memorySaved = bridgeStats.totalBytesTransferred; // Full data duplication avoided
                
                addResult(
                    `‚ö° Performance: ${totalTime}s total, ${avgTime}s per song | ` +
                    `${bridgeStats.totalMBTransferred}MB transferred | ` +
                    `Avg transfer: ${avgTransfer.toFixed(1)}ms | ` +
                    `Est. ${(memorySaved / 1024 / 1024).toFixed(1)}MB memory saved vs copying`,
                    'info'
                );
            }
            
            async downloadZip() {
                const zip = new JSZip();
                
                for (const [filename, content] of Object.entries(this.analysisFiles)) {
                    zip.file(filename, content);
                }
                
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `music_analysis_${Date.now()}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                addResult(`üì¶ Downloaded ${Object.keys(this.analysisFiles).length} analysis files as ZIP`, 'success');
            }
            
            startPerformanceMonitor() {
                setInterval(() => {
                    const bridgeStats = this.dataManager.getStats();
                    const poolStats = this.workerPool.getStats();
                    
                    document.getElementById('metric-transfers').textContent = bridgeStats.activeBuffers;
                    document.getElementById('metric-data-transferred').textContent = bridgeStats.totalMBTransferred + ' MB';
                    
                    if (this.transferTimes.length > 0) {
                        const avgTransfer = this.transferTimes.reduce((sum, t) => sum + t.time, 0) / this.transferTimes.length;
                        document.getElementById('metric-avg-transfer').textContent = avgTransfer.toFixed(1) + ' ms';
                        
                        const totalSize = this.transferTimes.reduce((sum, t) => sum + t.size, 0);
                        const totalTime = this.transferTimes.reduce((sum, t) => sum + t.time, 0) / 1000;
                        const throughput = totalTime > 0 ? (totalSize / totalTime / (1024 * 1024)) : 0;
                        document.getElementById('metric-throughput').textContent = throughput.toFixed(1) + ' MB/s';
                    }
                    
                    document.getElementById('metric-workers').textContent = poolStats.totalWorkers;
                    
                    // Estimate memory saved (vs copying the data)
                    const memorySaved = bridgeStats.totalBytesTransferred;
                    document.getElementById('metric-memory-saved').textContent = 
                        (memorySaved / 1024 / 1024).toFixed(1) + ' MB';
                    
                }, 500);
            }
            determineAnalysisStrategy(audioBuffer, filename) {
    const duration = audioBuffer.duration;
    const sampleRate = audioBuffer.sampleRate;
    
    // Short songs: full analysis
    if (duration < 180) { // < 3 minutes
        return {
            maxSegments: 20,
            fftSize: 8192,
            chromaSegments: 20,
            bpmWindow: 30,
            priority: 'high',
            reason: 'short-song'
        };
    }
    
    // Long songs: optimized analysis
    if (duration > 360) { // > 6 minutes
        return {
            maxSegments: 12,
            fftSize: 4096,
            chromaSegments: 12,
            bpmWindow: 20,
            priority: 'normal',
            reason: 'long-song-optimized'
        };
    }
    
    // Very long songs: aggressive optimization
    if (duration > 600) { // > 10 minutes
        return {
            maxSegments: 8,
            fftSize: 2048,
            chromaSegments: 8,
            bpmWindow: 15,
            priority: 'low',
            reason: 'very-long-song'
        };
    }
    
    // Normal songs: balanced
    return {
        maxSegments: 15,
        fftSize: 8192,
        chromaSegments: 15,
        bpmWindow: 25,
        priority: 'normal',
        reason: 'balanced'
    };
}
        }
        
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        function addResult(message, type, analysis = null) {
            const resultsDiv = document.getElementById('results');
            const item = document.createElement('div');
            item.className = `result-item ${type}`;
            item.innerHTML = `<div class="result-title">${message}</div>`;
            
            if (analysis) {
                const preview = document.createElement('div');
                preview.className = 'analysis-preview';
                preview.textContent = `BPM: ${analysis.bpm} | Key: ${analysis.key} ${analysis.mode} | Genre: ${analysis.genre} | Energy: ${(analysis.energy * 100).toFixed(0)}% | Mood: ${analysis.mood}`;
                item.appendChild(preview);
            }
            
            resultsDiv.appendChild(item);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }
        
        function updateStats(stats) {
            document.getElementById('stat-total').textContent = stats.total;
            document.getElementById('stat-analyzed').textContent = stats.analyzed;
            document.getElementById('stat-errors').textContent = stats.errors;
            
            const elapsed = Math.floor((Date.now() - app.startTime) / 1000);
            document.getElementById('stat-time').textContent = `${elapsed}s`;
        }
        
        function formatAnalysisAsText(filename, analysis) {
    return `ADVANCED MUSIC ANALYSIS
================================================================================
File: ${filename}
Analyzed: ${new Date().toLocaleString()}
Analysis Method: Advanced FFT + Chromagram + Autocorrelation
================================================================================

BASIC METRICS:
--------------
Duration: ${formatTime(analysis.duration)}
BPM: ${analysis.bpm} [Confidence: ${analysis.bpmConfidence === 'high' ? '‚úì High' : analysis.bpmConfidence === 'medium' ? '~ Medium' : '‚úó Low'}]
Key: ${analysis.key} ${analysis.mode} [Confidence: ${analysis.keyConfidence === 'high' ? '‚úì High' : analysis.keyConfidence === 'medium' ? '~ Medium' : '‚úó Low'}]
Tempo: ${analysis.tempo}
Genre: ${analysis.genre}
Mood: ${analysis.mood}

AUDIO CHARACTERISTICS:
----------------------
Energy: ${(analysis.energy * 100).toFixed(1)}% (${analysis.loudnessLUFS.toFixed(1)} LUFS)
Loudness: ${(analysis.loudness * 100).toFixed(1)}%
Danceability: ${(analysis.danceability * 100).toFixed(1)}%
Valence (Positivity): ${(analysis.valence * 100).toFixed(1)}%
Speechiness: ${(analysis.speechiness * 100).toFixed(1)}%
Acousticness: ${(analysis.acousticness * 100).toFixed(1)}%
Instrumentalness: ${(analysis.instrumentalness * 100).toFixed(1)}%

SPECTRAL FEATURES:
------------------
Spectral Centroid: ${Math.round(analysis.spectralCentroid)} Hz
Spectral Rolloff: ${Math.round(analysis.spectralRolloff)} Hz
Spectral Flux: ${analysis.spectralFlux.toFixed(4)}
Zero-Crossing Rate: ${analysis.zeroCrossingRate.toFixed(6)}
Vocal Prominence: ${analysis.vocalProminence.toFixed(2)}

RHYTHM & DYNAMICS:
------------------
Onset Rate: ${analysis.onsetRate.toFixed(2)} onsets/sec
Rhythmic Complexity: ${analysis.rhythmicComplexity}
Crest Factor: ${analysis.dynamicRange.crestFactor.toFixed(1)} dB
Dynamic Range: ${analysis.dynamicRange.classification}
Peak Amplitude: ${analysis.dynamicRange.peak.toFixed(4)}
RMS: ${analysis.dynamicRange.rms.toFixed(4)}

FREQUENCY BANDS:
----------------
Sub-Bass (<60 Hz): ${(analysis.frequencyBands.subBass * 100).toFixed(1)}%
Bass (60-200 Hz): ${(analysis.frequencyBands.bass * 100).toFixed(1)}%
Low-Mid (200-500 Hz): ${(analysis.frequencyBands.lowMid * 100).toFixed(1)}%
Midrange (500-2000 Hz): ${(analysis.frequencyBands.midrange * 100).toFixed(1)}%
Presence (2000-6000 Hz): ${(analysis.frequencyBands.presence * 100).toFixed(1)}%
Brilliance (6000+ Hz): ${(analysis.frequencyBands.brilliance * 100).toFixed(1)}%

RECORDING CHARACTERISTICS:
--------------------------
Vintage Recording: ${analysis.isVintage ? 'Yes' : 'No'}

================================================================================
Generated by Advanced Music Analysis Tool
Algorithms: FFT, Chromagram, Autocorrelation, Onset Detection
For use with Ultimate Local Music Player
================================================================================`;
}
        
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }
        
        // ============================================================================
        // WORKER CODE
        // ============================================================================
        
// ============================================================================
        // WORKER CODE - FULL ANALYSIS ALGORITHMS
        // ============================================================================
        
        function getWorkerCode() {
    return `
        const MSG_TYPES = ${JSON.stringify(MSG)};
        
        self.onmessage = async function(e) {
            const { type, requestId, data } = e.data;
            
            try {
                if (type === MSG_TYPES.PING) {
                    self.postMessage({ type: MSG_TYPES.PONG, requestId });
                    return;
                }
                
                if (type === MSG_TYPES.ANALYZE_AUDIO) {
    // Reconstruct Float32Array from transferred ArrayBuffer
    const channelData = [];
    for (const ch of data.channels) {
        const float32 = new Float32Array(ch.buffer, ch.byteOffset, ch.byteLength / 4);
        channelData.push(float32);
    }
    
    // Get analysis strategy (with defaults)
    const strategy = data.strategy || {
        maxSegments: 15,
        fftSize: 8192,
        chromaSegments: 15,
        bpmWindow: 25
    };
    
    // Mix to mono if stereo
    const mono = data.numberOfChannels === 1 
        ? Array.from(channelData[0])
        : Array.from(channelData[0]).map((v, i) => (v + channelData[1][i]) / 2);
    
    // FULL ADVANCED ANALYSIS (now with strategy)
    const spectralFeatures = await computeSpectralFeatures(mono, data.sampleRate, strategy);
    const bpmResult = await detectBPMAutocorrelation(mono, data.sampleRate, strategy);
    const keyResult = await detectKeyChromagram(mono, data.sampleRate, strategy);
                    const energyAnalysis = computeEnergyMetrics(mono, data.sampleRate);
                    const rhythmFeatures = await detectOnsets(mono, data.sampleRate);
                    const zcr = computeZeroCrossingRate(mono);
                    
                    const speechiness = computeSpeechiness(spectralFeatures, zcr);
                    const acousticness = computeAcousticness(spectralFeatures, energyAnalysis);
                    const valence = computeValence(bpmResult.bpm, energyAnalysis.energy, spectralFeatures.spectralCentroid, keyResult, energyAnalysis.dynamicRange);
                    const instrumentalness = 1 - speechiness;
                    
                    const genre = classifyGenre({
                        bpm: bpmResult.bpm,
                        energy: energyAnalysis.energy,
                        spectralCentroid: spectralFeatures.spectralCentroid,
                        bassEnergy: spectralFeatures.frequencyBands.bass,
                        danceability: rhythmFeatures.danceability,
                        valence: valence
                    });
                    
                    const mood = detectMoodAdvanced(energyAnalysis.energy, valence, bpmResult.bpm);
                    
                    self.postMessage({
                        type: MSG_TYPES.ANALYSIS_COMPLETE,
                        requestId,
                        data: {
                            filename: data.filename,
                            duration: data.duration,
                            bpm: bpmResult.bpm,
                            bpmConfidence: bpmResult.confidence,
                            key: keyResult.key,
                            keyConfidence: keyResult.confidence,
                            mode: keyResult.mode,
                            energy: energyAnalysis.energy,
                            loudness: energyAnalysis.loudness,
                            loudnessLUFS: energyAnalysis.loudnessLUFS,
                            danceability: rhythmFeatures.danceability,
                            valence: valence,
                            speechiness: speechiness,
                            acousticness: acousticness,
                            instrumentalness: instrumentalness,
                            spectralCentroid: spectralFeatures.spectralCentroid,
                            spectralRolloff: spectralFeatures.spectralRolloff,
                            spectralFlux: spectralFeatures.spectralFlux,
                            zeroCrossingRate: zcr,
                            mood: mood,
                            genre: genre,
                            tempo: classifyTempo(bpmResult.bpm),
                            dynamicRange: energyAnalysis.dynamicRange,
                            frequencyBands: spectralFeatures.frequencyBands,
                            vocalProminence: spectralFeatures.frequencyBands.presence / (spectralFeatures.frequencyBands.lowMid + 0.001),
                            isVintage: detectVintage(spectralFeatures.spectralCentroid, energyAnalysis.dynamicRange.crestFactor, spectralFeatures.frequencyBands),
                            onsetRate: rhythmFeatures.onsetRate,
                            rhythmicComplexity: rhythmFeatures.complexity
                        }
                    });
                }
            } catch (error) {
                self.postMessage({
                    type: MSG_TYPES.WORKER_ERROR,
                    requestId,
                    error: error.message
                });
            }
        };
        
        // === UTILITY FUNCTIONS ===
        function yieldToMainThread() {
            return new Promise(resolve => setTimeout(resolve, 0));
        }
        
        // === SPECTRAL ANALYSIS ===
        function computePowerSpectrum(signal) {
    // Proper Cooley-Tukey FFT implementation
    const fftSize = Math.pow(2, Math.ceil(Math.log2(signal.length)));
    const padded = new Float32Array(fftSize);
    
    // Apply Hamming window and pad
    for (let i = 0; i < signal.length; i++) {
        padded[i] = signal[i] * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / (signal.length - 1)));
    }
    
    // Perform FFT
    const real = new Float32Array(padded);
    const imag = new Float32Array(fftSize);
    fft(real, imag);
    
    // Compute magnitude spectrum (only need first half due to symmetry)
    const spectrum = new Float32Array(fftSize / 2);
    for (let i = 0; i < spectrum.length; i++) {
        spectrum[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / fftSize;
    }
    
    return spectrum;
}

// Cooley-Tukey FFT (radix-2, in-place)
function fft(real, imag) {
    const n = real.length;
    if (n <= 1) return;
    
    // Bit-reversal permutation
    let j = 0;
    for (let i = 0; i < n - 1; i++) {
        if (i < j) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
        }
        let k = n >> 1;
        while (k <= j) {
            j -= k;
            k >>= 1;
        }
        j += k;
    }
    
    // Cooley-Tukey butterfly computations
    for (let size = 2; size <= n; size *= 2) {
        const halfSize = size / 2;
        const angle = -2 * Math.PI / size;
        
        for (let i = 0; i < n; i += size) {
            for (let k = 0; k < halfSize; k++) {
                const theta = angle * k;
                const wReal = Math.cos(theta);
                const wImag = Math.sin(theta);
                
                const evenIdx = i + k;
                const oddIdx = i + k + halfSize;
                
                const tReal = wReal * real[oddIdx] - wImag * imag[oddIdx];
                const tImag = wReal * imag[oddIdx] + wImag * real[oddIdx];
                
                real[oddIdx] = real[evenIdx] - tReal;
                imag[oddIdx] = imag[evenIdx] - tImag;
                real[evenIdx] += tReal;
                imag[evenIdx] += tImag;
            }
        }
    }
}
        
        async function computeSpectralFeatures(data, sampleRate, strategy) {
    const segmentDuration = 5;
    const numSegments = Math.min(
        strategy.maxSegments, 
        Math.ceil(data.length / (segmentDuration * sampleRate))
    );
            let totalCentroid = 0, totalRolloff = 0, fluxSum = 0;
            const frequencyBands = { subBass: 0, bass: 0, lowMid: 0, midrange: 0, presence: 0, brilliance: 0 };
            let prevSpectrum = null;
            
            for (let seg = 0; seg < numSegments; seg++) {
                if (seg % 2 === 0) await yieldToMainThread();
                
                const startSample = Math.floor(seg * segmentDuration * sampleRate);
                const segmentLength = Math.min(8192, data.length - startSample);
                const segment = data.slice(startSample, startSample + segmentLength);
                const spectrum = computePowerSpectrum(segment);
                
                let weightedSum = 0, totalPower = 0;
                for (let i = 0; i < spectrum.length; i++) {
                    const freq = (i / spectrum.length) * (sampleRate / 2);
                    weightedSum += freq * spectrum[i];
                    totalPower += spectrum[i];
                    
                    if (freq < 60) frequencyBands.subBass += spectrum[i];
                    else if (freq < 200) frequencyBands.bass += spectrum[i];
                    else if (freq < 500) frequencyBands.lowMid += spectrum[i];
                    else if (freq < 2000) frequencyBands.midrange += spectrum[i];
                    else if (freq < 6000) frequencyBands.presence += spectrum[i];
                    else frequencyBands.brilliance += spectrum[i];
                }
                
                totalCentroid += totalPower > 0 ? weightedSum / totalPower : 1500;
                
                let energySum = 0;
                const threshold = totalPower * 0.85;
                let rolloff = 0;
                for (let i = 0; i < spectrum.length; i++) {
                    energySum += spectrum[i];
                    if (energySum >= threshold) {
                        rolloff = (i / spectrum.length) * (sampleRate / 2);
                        break;
                    }
                }
                totalRolloff += rolloff;
                
                if (prevSpectrum) {
                    let flux = 0;
                    for (let i = 0; i < Math.min(spectrum.length, prevSpectrum.length); i++) {
                        const diff = spectrum[i] - prevSpectrum[i];
                        flux += diff * diff;
                    }
                    fluxSum += Math.sqrt(flux);
                }
                prevSpectrum = spectrum;
            }
            
            const totalBandEnergy = Object.values(frequencyBands).reduce((sum, val) => sum + val, 0);
            if (totalBandEnergy > 0) {
                Object.keys(frequencyBands).forEach(key => {
                    frequencyBands[key] = frequencyBands[key] / totalBandEnergy;
                });
            }
            
            return {
                spectralCentroid: totalCentroid / numSegments,
                spectralRolloff: totalRolloff / numSegments,
                spectralFlux: fluxSum / (numSegments - 1),
                frequencyBands: frequencyBands
            };
        }
        
        // === BPM DETECTION ===
        function computeOnsetEnvelope(data, sampleRate) {
            const hopSize = 512;
            const envelope = [];
            let prevEnergy = 0;
            for (let i = 0; i < data.length - hopSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < hopSize; j++) {
                    energy += data[i + j] * data[i + j];
                }
                envelope.push(Math.max(0, energy - prevEnergy));
                prevEnergy = energy;
            }
            return envelope;
        }
        
        function detectBPMFromPeaks(data, sampleRate) {
            const hopSize = 512;
            const peaks = [];
            const energyEnvelope = [];
            
            for (let i = 0; i < data.length - hopSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < hopSize; j++) {
                    energy += data[i + j] * data[i + j];
                }
                energyEnvelope.push(Math.sqrt(energy / hopSize));
            }
            
            const smoothed = [];
            const smoothWindow = 3;
            for (let i = 0; i < energyEnvelope.length; i++) {
                let sum = 0, count = 0;
                for (let j = Math.max(0, i - smoothWindow); j <= Math.min(energyEnvelope.length - 1, i + smoothWindow); j++) {
                    sum += energyEnvelope[j];
                    count++;
                }
                smoothed.push(sum / count);
            }
            
            const mean = smoothed.reduce((a, b) => a + b) / smoothed.length;
            const stdDev = Math.sqrt(smoothed.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / smoothed.length);
            const threshold = mean + stdDev * 0.5;
            const minPeakDistance = Math.floor(sampleRate / hopSize * 0.25);
            
            for (let i = 1; i < smoothed.length - 1; i++) {
                if (smoothed[i] > threshold && smoothed[i] > smoothed[i - 1] && smoothed[i] > smoothed[i + 1]) {
                    if (peaks.length === 0 || i - peaks[peaks.length - 1] >= minPeakDistance) {
                        peaks.push(i);
                    }
                }
            }
            
            if (peaks.length < 4) return { bpm: 120, confidence: 'low' };
            
            const intervals = [];
            for (let i = 1; i < Math.min(peaks.length, 50); i++) {
                intervals.push(peaks[i] - peaks[i - 1]);
            }
            
            const intervalCounts = {};
            intervals.forEach(interval => {
                const rounded = Math.round(interval / 5) * 5;
                intervalCounts[rounded] = (intervalCounts[rounded] || 0) + 1;
            });
            
            let mostCommonInterval = 0, maxCount = 0;
            for (const [interval, count] of Object.entries(intervalCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostCommonInterval = parseInt(interval);
                }
            }
            
            const secondsPerBeat = (mostCommonInterval * hopSize) / sampleRate;
            const bpm = Math.round(60 / secondsPerBeat);
            const consistency = maxCount / intervals.length;
            const confidence = consistency > 0.5 ? 'high' : consistency > 0.3 ? 'medium' : 'low';
            
            return { bpm: Math.max(40, Math.min(200, bpm)), confidence };
        }
        
        function detectBPMAutocorr(data, sampleRate) {
            const onsetEnvelope = computeOnsetEnvelope(data, sampleRate);
            const downsampleFactor = 100;
            const downsampled = [];
            for (let i = 0; i < onsetEnvelope.length; i += downsampleFactor) {
                downsampled.push(onsetEnvelope[i]);
            }
            
            if (downsampled.length < 100) return { bpm: 120, confidence: 'low' };
            
            const minLag = Math.floor((60 / 180) * (sampleRate / (512 * downsampleFactor)));
            const maxLag = Math.floor((60 / 50) * (sampleRate / (512 * downsampleFactor)));
            let maxCorr = -Infinity, bestLag = minLag;
            
            for (let lag = minLag; lag < Math.min(maxLag, downsampled.length / 2); lag++) {
                let corr = 0, norm1 = 0, norm2 = 0;
                for (let i = 0; i < downsampled.length - lag; i++) {
                    corr += downsampled[i] * downsampled[i + lag];
                    norm1 += downsampled[i] * downsampled[i];
                    norm2 += downsampled[i + lag] * downsampled[i + lag];
                }
                const normalizedCorr = corr / (Math.sqrt(norm1 * norm2) + 0.0001);
                if (normalizedCorr > maxCorr) {
                    maxCorr = normalizedCorr;
                    bestLag = lag;
                }
            }
            
            const bpm = Math.round((60 * (sampleRate / (512 * downsampleFactor))) / bestLag);
            const confidence = maxCorr > 0.5 ? 'high' : maxCorr > 0.3 ? 'medium' : 'low';
            return { bpm: Math.max(40, Math.min(200, bpm)), confidence };
        }
        
        function detectBPMComb(data, sampleRate) {
            const onsetEnvelope = computeOnsetEnvelope(data, sampleRate);
            if (onsetEnvelope.length < 100) return { bpm: 120, confidence: 'low' };
            
            const hopSize = 512;
            const hopRate = sampleRate / hopSize;
            let maxScore = 0, bestBPM = 120;
            
            for (let testBPM = 60; testBPM <= 180; testBPM++) {
                const beatPeriod = (60 / testBPM) * hopRate;
                let score = 0, numBeats = 0;
                for (let beat = 0; beat * beatPeriod < onsetEnvelope.length; beat++) {
                    const idx = Math.round(beat * beatPeriod);
                    if (idx < onsetEnvelope.length) {
                        score += onsetEnvelope[idx];
                        numBeats++;
                    }
                }
                score /= (numBeats + 1);
                if (score > maxScore) {
                    maxScore = score;
                    bestBPM = testBPM;
                }
            }
            
            const avgEnergy = onsetEnvelope.reduce((a, b) => a + b, 0) / onsetEnvelope.length;
            const relativeScore = maxScore / (avgEnergy + 0.0001);
            const confidence = relativeScore > 1.5 ? 'high' : relativeScore > 1.2 ? 'medium' : 'low';
            return { bpm: bestBPM, confidence };
        }
        
        function pickBestBPM(candidates) {
            const weights = { 'high': 3, 'medium': 2, 'low': 1 };
            const agreementGroups = [];
            
            for (let i = 0; i < candidates.length; i++) {
                const candidate = candidates[i];
                let addedToGroup = false;
                for (const group of agreementGroups) {
                    const groupBPM = group[0].bpm;
                    if (Math.abs(candidate.bpm - groupBPM) / groupBPM < 0.05 ||
                        Math.abs(candidate.bpm - groupBPM * 2) / (groupBPM * 2) < 0.05 ||
                        Math.abs(candidate.bpm - groupBPM / 2) / (groupBPM / 2) < 0.05) {
                        group.push(candidate);
                        addedToGroup = true;
                        break;
                    }
                }
                if (!addedToGroup) agreementGroups.push([candidate]);
            }
            
            let bestGroup = agreementGroups[0], maxWeight = 0;
            for (const group of agreementGroups) {
                const totalWeight = group.reduce((sum, c) => sum + weights[c.confidence], 0);
                if (totalWeight > maxWeight) {
                    maxWeight = totalWeight;
                    bestGroup = group;
                }
            }
            bestGroup.sort((a, b) => weights[b.confidence] - weights[a.confidence]);
            return bestGroup[0];
        }
        
        function correctTempoMultiples(bpm) {
            if (bpm > 170) return Math.round(bpm / 2);
            if (bpm < 70) return Math.round(bpm * 2);
            if (bpm >= 195 && bpm <= 205) return 100;
            return bpm;
        }
        
        async function detectBPMAutocorrelation(data, sampleRate) {
            const maxDuration = 30;
            const maxSamples = Math.min(data.length, sampleRate * maxDuration);
            const analyzedData = data.slice(0, maxSamples);
            
            const peakBPM = detectBPMFromPeaks(analyzedData, sampleRate);
            const autoCorrBPM = detectBPMAutocorr(analyzedData, sampleRate);
            const combBPM = detectBPMComb(analyzedData, sampleRate);
            
            const candidates = [peakBPM, autoCorrBPM, combBPM];
            const bestBPM = pickBestBPM(candidates);
            const correctedBPM = correctTempoMultiples(bestBPM.bpm);
            
            return { bpm: correctedBPM, confidence: bestBPM.confidence };
        }
        
        // === KEY DETECTION ===
        function computeChromagram(data, sampleRate) {
            const chroma = new Array(12).fill(0);
            const segmentSize = 8192;
            const numSegments = Math.min(20, Math.floor(data.length / segmentSize));
            
            for (let seg = 0; seg < numSegments; seg++) {
                const start = seg * segmentSize;
                const segment = data.slice(start, start + segmentSize);
                const spectrum = computePowerSpectrum(segment);
                
                for (let i = 1; i < spectrum.length; i++) {
                    const freq = (i / spectrum.length) * (sampleRate / 2);
                    if (freq < 60 || freq > 4000) continue;
                    
                    const midiNote = 12 * Math.log2(freq / 440) + 69;
                    const pitchClass = Math.round(midiNote) % 12;
                    if (pitchClass >= 0 && pitchClass < 12) {
                        chroma[pitchClass] += spectrum[i];
                    }
                }
            }
            
            const total = chroma.reduce((sum, val) => sum + val, 0);
            if (total > 0) {
                for (let i = 0; i < 12; i++) chroma[i] /= total;
            }
            return chroma;
        }
        
        async function detectKeyChromagram(data, sampleRate) {
            const chromagram = computeChromagram(data, sampleRate);
            const majorProfile = [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88];
            const minorProfile = [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17];
            const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            
            let bestKey = 'C', bestMode = 'major', maxCorr = -Infinity;
            for (let shift = 0; shift < 12; shift++) {
                let corrMajor = 0;
                for (let i = 0; i < 12; i++) {
                    corrMajor += chromagram[(i + shift) % 12] * majorProfile[i];
                }
                if (corrMajor > maxCorr) {
                    maxCorr = corrMajor;
                    bestKey = keys[shift];
                    bestMode = 'major';
                }
                
                let corrMinor = 0;
                for (let i = 0; i < 12; i++) {
                    corrMinor += chromagram[(i + shift) % 12] * minorProfile[i];
                }
                if (corrMinor > maxCorr) {
                    maxCorr = corrMinor;
                    bestKey = keys[shift];
                    bestMode = 'minor';
                }
            }
            
            const avgProfile = majorProfile.reduce((a, b) => a + b) / 12;
            const avgChroma = chromagram.reduce((a, b) => a + b) / 12;
            const confidence = Math.min(1, maxCorr / (avgProfile * avgChroma * 12));
            
            return {
                key: bestKey,
                mode: bestMode,
                confidence: confidence > 0.7 ? 'high' : confidence > 0.4 ? 'medium' : 'low'
            };
        }
        
        // === ENERGY ANALYSIS ===
        function computeEnergyMetrics(data, sampleRate) {
            const segmentDuration = 2;
            const segmentSize = Math.floor(segmentDuration * sampleRate);
            const numSegments = Math.floor(data.length / segmentSize);
            
            if (numSegments < 1) {
                let sumSquares = 0, peakAmplitude = 0;
                for (let i = 0; i < data.length; i++) {
                    sumSquares += data[i] * data[i];
                    peakAmplitude = Math.max(peakAmplitude, Math.abs(data[i]));
                }
                const rms = Math.sqrt(sumSquares / data.length);
                const loudnessLUFS = rms > 0.000001 ? Math.max(-70, 20 * Math.log10(rms)) : -70;
                const energy = Math.max(0, Math.min(1, (loudnessLUFS + 30) / 20));
                return {
                    energy: energy,
                    loudness: energy,
                    loudnessLUFS: loudnessLUFS,
                    dynamicRange: { crestFactor: 0, peak: peakAmplitude, rms: rms, classification: 'moderate' }
                };
            }
            
            const segmentRMS = [];
            let globalPeak = 0;
            for (let seg = 0; seg < numSegments; seg++) {
                const start = seg * segmentSize;
                const end = Math.min(start + segmentSize, data.length);
                let sumSquares = 0, segPeak = 0;
                for (let i = start; i < end; i++) {
                    const sample = data[i];
                    sumSquares += sample * sample;
                    const absSample = Math.abs(sample);
                    segPeak = Math.max(segPeak, absSample);
                    globalPeak = Math.max(globalPeak, absSample);
                }
                segmentRMS.push(Math.sqrt(sumSquares / (end - start)));
            }
            
            const sortedRMS = [...segmentRMS].sort((a, b) => a - b);
            const percentile80Index = Math.floor(sortedRMS.length * 0.80);
            const percentile80RMS = sortedRMS[percentile80Index];
            const meanRMS = segmentRMS.reduce((sum, val) => sum + val, 0) / segmentRMS.length;
            const weightedRMS = percentile80RMS * 0.7 + meanRMS * 0.3;
            const loudnessLUFS = weightedRMS > 0.000001 ? Math.max(-70, 20 * Math.log10(weightedRMS)) : -70;
            const energy = Math.max(0, Math.min(1, (loudnessLUFS + 30) / 25));
            const crestFactor = globalPeak > 0 && weightedRMS > 0 ? 20 * Math.log10(globalPeak / weightedRMS) : 0;
            
            return {
                energy: energy,
                loudness: energy,
                loudnessLUFS: loudnessLUFS,
                dynamicRange: {
                    crestFactor: Math.max(0, Math.min(30, crestFactor)),
                    peak: globalPeak,
                    rms: weightedRMS,
                    classification: crestFactor > 12 ? 'high' : crestFactor < 6 ? 'low' : 'moderate'
                }
            };
        }
        
        // === RHYTHM ANALYSIS ===
        async function detectOnsets(data, sampleRate) {
            const hopSize = 512;
            const onsets = [];
            let prevSpectrum = null;
            
            for (let i = 0; i < data.length - hopSize; i += hopSize) {
                const segment = data.slice(i, i + hopSize);
                const spectrum = computePowerSpectrum(segment);
                
                if (prevSpectrum) {
                    let flux = 0;
                    for (let j = 0; j < Math.min(spectrum.length, prevSpectrum.length); j++) {
                        const diff = spectrum[j] - prevSpectrum[j];
                        flux += Math.max(0, diff);
                    }
                    if (flux > 0.01) {
                        onsets.push({ time: i / sampleRate, strength: flux });
                    }
                }
                prevSpectrum = spectrum;
            }
            
            const onsetRate = onsets.length / (data.length / sampleRate);
            if (onsets.length < 10) return { onsetRate: onsetRate, danceability: 0.3, complexity: 'low' };
            
            const intervals = [];
            for (let i = 1; i < Math.min(onsets.length, 100); i++) {
                intervals.push(onsets[i].time - onsets[i - 1].time);
            }
            if (intervals.length < 5) return { onsetRate: onsetRate, danceability: 0.4, complexity: 'low' };
            
            const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
            let sumSquaredDiffs = 0;
            for (const interval of intervals) {
                sumSquaredDiffs += Math.pow(interval - avgInterval, 2);
            }
            const stdDev = Math.sqrt(sumSquaredDiffs / intervals.length);
            const coefficientOfVariation = avgInterval > 0 ? stdDev / avgInterval : 1;
            const danceability = Math.max(0.1, Math.min(1.0, 1.0 - coefficientOfVariation * 0.8));
            const complexity = coefficientOfVariation > 0.6 ? 'high' : coefficientOfVariation > 0.3 ? 'medium' : 'low';
            
            return { onsetRate: onsetRate, danceability: danceability, complexity: complexity };
        }
        
        function computeZeroCrossingRate(data) {
            let crossings = 0;
            for (let i = 1; i < data.length; i++) {
                if ((data[i] >= 0 && data[i - 1] < 0) || (data[i] < 0 && data[i - 1] >= 0)) {
                    crossings++;
                }
            }
            return crossings / data.length;
        }
        
        // === ADVANCED FEATURES ===
        function computeSpeechiness(spectralFeatures, zcr) {
            const voiceRangeFactor = spectralFeatures.spectralCentroid >= 1000 && 
                                    spectralFeatures.spectralCentroid <= 3000 ? 1.0 : 0.5;
            const presenceFactor = Math.min(1, spectralFeatures.frequencyBands.presence * 5);
            const lowBassFactor = 1 - Math.min(1, spectralFeatures.frequencyBands.bass * 4);
            const zcrFactor = Math.min(1, zcr * 80);
            return Math.max(0, Math.min(1, voiceRangeFactor * 0.3 + presenceFactor * 0.3 + lowBassFactor * 0.2 + zcrFactor * 0.2));
        }
        
        function computeAcousticness(spectralFeatures, energyAnalysis) {
            const midRatio = spectralFeatures.frequencyBands.midrange / 
                           (spectralFeatures.frequencyBands.bass + spectralFeatures.frequencyBands.brilliance + 0.001);
            const dynamicFactor = energyAnalysis.dynamicRange.crestFactor / 20;
            return Math.max(0, Math.min(1, (midRatio * 0.6 + dynamicFactor * 0.4)));
        }
        
        function computeValence(bpm, energy, spectralCentroid, keyResult, dynamicRange) {
            const bpmFactor = Math.max(0, Math.min(1, (bpm - 60) / 140));
            const brightnessFactor = Math.max(0, Math.min(1, (spectralCentroid - 1000) / 2000));
            const keyMoodFactor = keyResult.mode === 'major' ? 0.65 : 0.35;
            const dynamicFactor = Math.max(0, Math.min(1, dynamicRange.crestFactor / 15));
            return Math.max(0, Math.min(1, bpmFactor * 0.2 + energy * 0.25 + brightnessFactor * 0.15 + keyMoodFactor * 0.3 + dynamicFactor * 0.1));
        }
        
        // === GENRE & MOOD ===
        function classifyGenre(features) {
    const scores = {
        'Electronic/Dance': 0,
        'Rock': 0,
        'Hip-Hop/Rap': 0,
        'Classical': 0,
        'Jazz': 0,
        'Pop': 0,
        'Metal': 0,
        'Country': 0,
        'R&B/Soul': 0,
        'Ambient': 0
    };
    
    // Electronic/Dance: High BPM + High energy + Strong bass + Very high danceability
    if (features.bpm >= 120 && features.bpm <= 140 && features.energy > 0.65) scores['Electronic/Dance'] += 4;
    if (features.danceability > 0.75) scores['Electronic/Dance'] += 4;
    if (features.bassEnergy > 0.22) scores['Electronic/Dance'] += 3;
    if (features.spectralCentroid > 2000) scores['Electronic/Dance'] += 2;
    if (features.valence > 0.5) scores['Electronic/Dance'] += 1;
    // Penalty if too slow
    if (features.bpm < 100) scores['Electronic/Dance'] -= 3;
    
    // Rock: Mid-high BPM + Mid-high energy + Prominent midrange + Moderate danceability
    if (features.bpm >= 100 && features.bpm <= 160) scores['Rock'] += 3;
    if (features.energy >= 0.55 && features.energy <= 0.85) scores['Rock'] += 4;
    if (features.spectralCentroid >= 1500 && features.spectralCentroid <= 2800) scores['Rock'] += 3;
    if (features.danceability >= 0.35 && features.danceability <= 0.65) scores['Rock'] += 2;
    // Rock typically has strong dynamics
    if (features.bassEnergy >= 0.15 && features.bassEnergy <= 0.25) scores['Rock'] += 2;
    
    // Hip-Hop/Rap: Low-mid BPM + VERY strong bass + Lower spectral centroid
    if (features.bassEnergy > 0.27) scores['Hip-Hop/Rap'] += 5;
    if (features.bpm >= 75 && features.bpm <= 115) scores['Hip-Hop/Rap'] += 4;
    if (features.spectralCentroid < 1800) scores['Hip-Hop/Rap'] += 2;
    if (features.energy >= 0.5 && features.energy <= 0.75) scores['Hip-Hop/Rap'] += 2;
    // Hip-hop usually has good groove
    if (features.danceability > 0.5) scores['Hip-Hop/Rap'] += 2;
    
    // Classical: High spectral centroid + Low danceability + Wider dynamic range + Lower energy
    if (features.spectralCentroid > 2000) scores['Classical'] += 3;
    if (features.danceability < 0.35) scores['Classical'] += 4;
    if (features.energy < 0.55) scores['Classical'] += 3;
    if (features.bassEnergy < 0.15) scores['Classical'] += 2;
    // Classical tends to have more dynamic variation
    if (features.bpm >= 60 && features.bpm <= 140) scores['Classical'] += 1;
    
    // Jazz: Complex rhythms + Mid spectral range + Moderate everything
    if (features.spectralCentroid >= 1600 && features.spectralCentroid <= 2400) scores['Jazz'] += 3;
    if (features.danceability >= 0.35 && features.danceability <= 0.55) scores['Jazz'] += 3;
    if (features.bpm >= 90 && features.bpm <= 180) scores['Jazz'] += 2;
    if (features.energy >= 0.4 && features.energy <= 0.7) scores['Jazz'] += 2;
    // Jazz often has less bass emphasis than other genres
    if (features.bassEnergy >= 0.10 && features.bassEnergy <= 0.20) scores['Jazz'] += 2;
    
    // Pop: Moderate-high BPM + High danceability + Positive valence + Mid-high energy
    if (features.bpm >= 100 && features.bpm <= 130) scores['Pop'] += 3;
    if (features.danceability >= 0.55 && features.danceability <= 0.80) scores['Pop'] += 4;
    if (features.valence > 0.5) scores['Pop'] += 3;
    if (features.energy >= 0.55 && features.energy <= 0.80) scores['Pop'] += 3;
    if (features.spectralCentroid >= 1600 && features.spectralCentroid <= 2200) scores['Pop'] += 2;
    
    // Metal: VERY high energy + High spectral centroid + Fast BPM + High bass
    if (features.energy > 0.80) scores['Metal'] += 5;
    if (features.spectralCentroid > 2500) scores['Metal'] += 4;
    if (features.bpm > 140) scores['Metal'] += 3;
    if (features.bassEnergy > 0.20) scores['Metal'] += 2;
    // Metal typically has lower danceability
    if (features.danceability < 0.5) scores['Metal'] += 2;
    
    // Country: Mid BPM + Balanced energy + Mid spectral range + Slight positive valence
    if (features.bpm >= 90 && features.bpm <= 130) scores['Country'] += 3;
    if (features.energy >= 0.45 && features.energy <= 0.70) scores['Country'] += 3;
    if (features.spectralCentroid >= 1400 && features.spectralCentroid <= 2100) scores['Country'] += 3;
    if (features.valence >= 0.45 && features.valence <= 0.70) scores['Country'] += 2;
    if (features.danceability >= 0.4 && features.danceability <= 0.6) scores['Country'] += 2;
    
    // R&B/Soul: Smooth, mid BPM + Good danceability + Mid energy + Moderate valence
    if (features.bpm >= 70 && features.bpm <= 110) scores['R&B/Soul'] += 3;
    if (features.danceability >= 0.50 && features.danceability <= 0.75) scores['R&B/Soul'] += 4;
    if (features.energy >= 0.40 && features.energy <= 0.70) scores['R&B/Soul'] += 3;
    if (features.valence >= 0.35 && features.valence <= 0.65) scores['R&B/Soul'] += 2;
    if (features.bassEnergy >= 0.18 && features.bassEnergy <= 0.25) scores['R&B/Soul'] += 2;
    
    // Ambient: LOW energy + Very low danceability + Slow BPM + Often ethereal (high centroid but low energy)
    if (features.energy < 0.35) scores['Ambient'] += 5;
    if (features.danceability < 0.30) scores['Ambient'] += 4;
    if (features.bpm < 100) scores['Ambient'] += 3;
    if (features.valence < 0.50) scores['Ambient'] += 1;
    
    // Find best match with minimum threshold
    let bestGenre = null;
    let maxScore = 0;
    let secondBestScore = 0;
    
    for (const [genre, score] of Object.entries(scores)) {
        if (score > maxScore) {
            secondBestScore = maxScore;
            maxScore = score;
            bestGenre = genre;
        } else if (score > secondBestScore) {
            secondBestScore = score;
        }
    }
    
    // Require minimum score of 8 and clear winner (30% margin)
    if (maxScore < 8 || (secondBestScore > 0 && maxScore / secondBestScore < 1.3)) {
        // Ambiguous - use simpler heuristics
        if (features.energy > 0.7 && features.bpm > 120) return 'Electronic/Dance';
        if (features.bassEnergy > 0.25) return 'Hip-Hop/Rap';
        if (features.energy < 0.4) return 'Ambient';
        return 'Pop'; // Last resort default
    }
    
    return bestGenre;
}
        
        function detectMoodAdvanced(energy, valence, bpm) {
            if (energy > 0.6) return valence > 0.5 ? 'Energetic' : 'Dark';
            if (energy < 0.4) return valence > 0.5 ? 'Calm' : 'Dark';
            if (valence > 0.55) return 'Bright';
            if (valence < 0.45) return 'Dark';
            return 'Neutral';
        }
        
        function classifyTempo(bpm) {
            if (bpm < 80) return 'slow';
            if (bpm < 110) return 'moderate';
            if (bpm < 140) return 'fast';
            return 'very-fast';
        }
        
        function detectVintage(spectralCentroid, crestFactor, frequencyBands) {
            let vintageScore = 0;
            if (spectralCentroid < 1500) vintageScore += 2;
            if (crestFactor > 12) vintageScore += 2;
            if (frequencyBands.subBass < 0.08) vintageScore += 1;
            if (frequencyBands.brilliance < 0.12) vintageScore += 1;
            return vintageScore >= 3;
        }
    `;
}
        
        // ============================================================================
        // INITIALIZE APPLICATION
        // ============================================================================
        
        let app;
        window.addEventListener('load', () => {
            app = new IntegratedMusicAnalyzer();
        });
    </script>
</body>
</html>