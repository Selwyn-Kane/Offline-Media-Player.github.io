<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Deep Music Analysis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
        }
        
        .instructions {
            background: rgba(40, 167, 69, 0.1);
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .instructions h2 {
            color: #28a745;
            margin-bottom: 15px;
        }
        
        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }
        
        .warning {
            background: rgba(255, 193, 7, 0.1);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 30px;
        }
        
        .warning strong {
            color: #ffc107;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.5);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        button.success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }
        
        #progress-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        #progress-section.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #222;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545 0%, #ff7788 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #dc3545;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }
        
        #results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #666;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .result-item.success {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }
        
        .result-item.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .result-detail {
            font-size: 0.9em;
            color: #aaa;
        }
        
        #results::-webkit-scrollbar {
            width: 8px;
        }
        
        #results::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        #results::-webkit-scrollbar-thumb {
            background: #dc3545;
            border-radius: 4px;
        }

        .analysis-preview {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #0f0;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Deep Music Analysis Tool</h1>
        
        <div class="instructions">
            <h2>üìñ How to Use</h2>
            <ol>
                <li>Click <strong>"Select Music Folder"</strong> and choose your music folder</li>
                <li>The tool will scan all audio files (MP3, M4A, FLAC, WAV, OGG)</li>
                <li>Click <strong>"Analyze All Songs"</strong> to perform deep analysis</li>
                <li>Wait for analysis to complete (this analyzes the ENTIRE song, not just chunks)</li>
                <li>Text files will be created with detailed analysis data</li>
                <li>Click <strong>"Download Analysis Files (ZIP)"</strong> to get all .txt files</li>
                <li>Extract the ZIP and place the .txt files in your music folder</li>
            </ol>
        </div>

        <div class="warning">
            <strong>‚ö†Ô∏è Performance Notice:</strong> This tool analyzes the ENTIRE duration of each song for maximum accuracy. 
            This process is CPU-intensive and may take 30-60 seconds per song. Please be patient!
        </div>
        
        <div class="button-group">
            <button id="select-folder-btn">üìÅ Select Music Folder</button>
            <button id="analyze-btn" disabled>üîç Analyze All Songs</button>
            <button id="download-zip-btn" disabled style="display: none;">üíæ Download Analysis Files (ZIP)</button>
        </div>
        
        <div id="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill">0%</div>
            </div>
            <div id="status-text" style="text-align: center; margin-bottom: 15px;">Ready...</div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="stat-total">0</div>
                    <div class="stat-label">Total Songs</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-analyzed" style="color: #28a745;">0</div>
                    <div class="stat-label">Analyzed</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-errors" style="color: #dc3545;">0</div>
                    <div class="stat-label">Errors</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="stat-time">0s</div>
                    <div class="stat-label">Elapsed Time</div>
                </div>
            </div>
        </div>
        
        <div id="results"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let musicFiles = [];
        let analysisFiles = {};
        let stats = { total: 0, analyzed: 0, errors: 0 };
        let startTime = 0;
        
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const analyzeBtn = document.getElementById('analyze-btn');
        const downloadZipBtn = document.getElementById('download-zip-btn');
        const progressSection = document.getElementById('progress-section');
        const progressFill = document.getElementById('progress-fill');
        const statusText = document.getElementById('status-text');
        const resultsDiv = document.getElementById('results');
        
        // Select music folder
        selectFolderBtn.onclick = async () => {
            try {
                const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
                
                musicFiles = [];
                statusText.textContent = 'Scanning folder...';
                progressSection.classList.add('show');
                
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        if (file.name.match(/\.(mp3|m4a|flac|wav|ogg|aac)$/i)) {
                            musicFiles.push(file);
                        }
                    }
                }
                
                stats.total = musicFiles.length;
                updateStats();
                
                addResult(`Found ${musicFiles.length} audio files`, 'success');
                statusText.textContent = `Ready to analyze ${musicFiles.length} songs`;
                analyzeBtn.disabled = false;
                selectFolderBtn.textContent = `‚úÖ ${musicFiles.length} Songs Loaded`;
                selectFolderBtn.classList.add('success');
                
            } catch (err) {
                addResult(`Error: ${err.message}`, 'error');
            }
        };
        
        // Analyze all songs
        analyzeBtn.onclick = async () => {
            if (musicFiles.length === 0) {
                alert('No tracks loaded!');
                return;
            }
            
            analyzeBtn.disabled = true;
            selectFolderBtn.disabled = true;
            resultsDiv.innerHTML = '';
            stats = { total: musicFiles.length, analyzed: 0, errors: 0 };
            analysisFiles = {};
            startTime = Date.now();
            
            for (let i = 0; i < musicFiles.length; i++) {
                const file = musicFiles[i];
                
                try {
                    const progress = ((i + 1) / musicFiles.length) * 100;
                    
                    progressFill.style.width = `${progress}%`;
                    progressFill.textContent = `${Math.round(progress)}%`;
                    statusText.textContent = `Deep analyzing: ${file.name} (${i + 1}/${musicFiles.length})`;
                    
                    // Perform DEEP analysis (entire song)
                    const analysis = await deepAnalyzeTrack(file);
                    
                    // Create text file content
                    const txtContent = formatAnalysisAsText(file.name, analysis);
                    const txtFilename = file.name.replace(/\.[^/.]+$/, '.txt');
                    analysisFiles[txtFilename] = txtContent;
                    
                    stats.analyzed++;
                    addResult(`‚úÖ ${file.name}: Deep analysis complete`, 'success', analysis);
                    
                } catch (err) {
                    stats.errors++;
                    addResult(`‚ùå ${file.name}: ${err.message}`, 'error');
                }
                
                updateStats();
                updateElapsedTime();
            }
            
            statusText.textContent = `‚úÖ Complete! Analyzed ${stats.analyzed}/${stats.total} songs`;
            analyzeBtn.disabled = false;
            selectFolderBtn.disabled = false;
            
            if (Object.keys(analysisFiles).length > 0) {
                downloadZipBtn.style.display = 'inline-block';
                downloadZipBtn.disabled = false;
            }
        };
        
        // Download ZIP
        downloadZipBtn.onclick = async () => {
            const zip = new JSZip();
            
            for (const [filename, content] of Object.entries(analysisFiles)) {
                zip.file(filename, content);
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `music_analysis_${Date.now()}.zip`;
            a.click();
            URL.revokeObjectURL(url);
            
            addResult(`üì¶ Downloaded ${Object.keys(analysisFiles).length} analysis files as ZIP`, 'success');
        };
        
        // DEEP ANALYSIS FUNCTION - Analyzes ENTIRE song
        async function deepAnalyzeTrack(file) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            console.log(`Deep analyzing: ${file.name} (${audioBuffer.duration.toFixed(1)}s)`);
            
            // Get full audio data (entire song)
            const channelData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const duration = audioBuffer.duration;
            
            // Analyze entire track in segments for comprehensive analysis
            const segmentDuration = 5; // 5 second segments
            const numSegments = Math.ceil(duration / segmentDuration);
            
            let totalEnergy = 0;
            let totalSpectralCentroid = 0;
            let energyVariance = 0;
            let peakAmplitude = 0;
            let rmsTotal = 0;
            let segmentEnergies = [];
            
            // Analyze each segment
            for (let seg = 0; seg < numSegments; seg++) {
                const startSample = Math.floor(seg * segmentDuration * sampleRate);
                const endSample = Math.min(startSample + segmentDuration * sampleRate, channelData.length);
                const segmentData = channelData.slice(startSample, endSample);
                
                // Energy calculation
                let segmentEnergy = 0;
                let segmentRMS = 0;
                for (let i = 0; i < segmentData.length; i++) {
                    const abs = Math.abs(segmentData[i]);
                    segmentEnergy += abs;
                    segmentRMS += segmentData[i] * segmentData[i];
                    if (abs > peakAmplitude) peakAmplitude = abs;
                }
                segmentEnergy /= segmentData.length;
                segmentRMS = Math.sqrt(segmentRMS / segmentData.length);
                
                totalEnergy += segmentEnergy;
                rmsTotal += segmentRMS;
                segmentEnergies.push(segmentEnergy);
                
                // Spectral centroid for this segment
                const centroid = calculateSpectralCentroid(segmentData, sampleRate);
                totalSpectralCentroid += centroid;
            }
            
            // Calculate averages
            const avgEnergy = totalEnergy / numSegments;
            const avgRMS = rmsTotal / numSegments;
            const avgSpectralCentroid = totalSpectralCentroid / numSegments;
            
            // Calculate energy variance (for danceability)
            for (const e of segmentEnergies) {
                energyVariance += Math.pow(e - avgEnergy, 2);
            }
            energyVariance = Math.sqrt(energyVariance / segmentEnergies.length);
            
            // BPM detection (accurate)
            const bpm = await detectBPMFromFullTrack(channelData, sampleRate);
            
            // === IMPROVED ENERGY CALCULATION (Most Accurate) ===
            // 1. First, analyze the ENTIRE track to find true maximum values
            let absoluteMax = 0;
            let squaredSum = 0;
            
            // Analyze every 1000th sample for performance (still accurate)
            for (let i = 0; i < channelData.length; i += 1000) {
                const absValue = Math.abs(channelData[i]);
                if (absValue > absoluteMax) absoluteMax = absValue;
                squaredSum += channelData[i] * channelData[i];
            }
            
            // 2. Calculate true RMS of entire track (most accurate energy measure)
            const trueRMS = Math.sqrt(squaredSum / Math.ceil(channelData.length / 1000));
            
            // 3. Calculate energy using perceptual loudness model (EBU R128 standard inspired)
            // Convert RMS to LUFS-like scale (-70 to 0 dB range mapped to 0-1)
            const rmsToLUFS = (rms) => {
                if (rms <= 0.000001) return -70; // Silence threshold
                return Math.max(-70, 20 * Math.log10(rms));
            };
            
            const loudnessLUFS = rmsToLUFS(trueRMS);
// Modern music is typically between -20 LUFS (quiet) and -5 LUFS (very loud)
// Map this range to 0-1 for energy
const energy = Math.max(0, Math.min(1, (loudnessLUFS + 20) / 15)); // Normalize -20 to -5 LUFS range
            
            // 4. Improved danceability based on energy variance AND beat consistency
            const normalizedVariance = Math.min(1, energyVariance * 2); // Scale variance appropriately
            
            // Helper function for target BPM (human-perceived ideal)
            function targetBPM(actualBPM) {
                if (actualBPM < 80) return 70;
                if (actualBPM < 100) return 90;
                if (actualBPM < 120) return 110;
                if (actualBPM < 140) return 130;
                return 150;
            }
            
            const beatConsistency = Math.min(1, Math.max(0, 1 - (Math.abs(bpm - targetBPM(bpm)) / 20)));
            const danceability = Math.max(0, Math.min(1, 
                0.6 * (1 - normalizedVariance) + 
                0.4 * beatConsistency
            ));
            
            // 5. Accurate loudness (perceptual)
            const loudness = Math.max(0, Math.min(1, (loudnessLUFS + 20) / 15)); // Same range as energy for consistency
            
            // Dynamic range
            const crestFactor = 20 * Math.log10((peakAmplitude + 0.0001) / (avgRMS + 0.0001));
            
            // Mood detection (enhanced with tempo consideration)
            const mood = detectMoodEnhanced(energy, avgSpectralCentroid, bpm);
            
            // Frequency band analysis
            const frequencyBands = analyzeFrequencyBands(channelData, sampleRate);
            
            // Key detection (simplified)
            const key = detectKeySimplified(channelData, sampleRate);
            
            await audioContext.close();
            
            return {
                duration: duration,
                bpm: bpm,
                energy: energy,
                spectralCentroid: avgSpectralCentroid,
                mood: mood,
                key: key,
                danceability: danceability,
                loudness: loudness,
                loudnessLUFS: loudnessLUFS,  // Added for text output
                tempo: classifyTempo(bpm),
                dynamicRange: {
                    crestFactor: Math.max(0, Math.min(30, crestFactor)),
                    peak: peakAmplitude,
                    rms: avgRMS,
                    classification: crestFactor > 12 ? 'high' : crestFactor < 6 ? 'low' : 'moderate'
                },
                frequencyBands: frequencyBands,
                vocalProminence: frequencyBands.presence / (frequencyBands.lowMid + 0.001),
                isVintage: detectVintage(avgSpectralCentroid, crestFactor, frequencyBands)
            };
        }
        
        // Calculate spectral centroid for a segment
        function calculateSpectralCentroid(data, sampleRate) {
            const numBands = 32;
            const samplesPerBand = Math.floor(data.length / numBands);
            
            let weightedSum = 0;
            let totalPower = 0;
            
            for (let band = 0; band < numBands; band++) {
                const bandStart = band * samplesPerBand;
                const bandEnd = Math.min(bandStart + samplesPerBand, data.length);
                
                let bandPower = 0;
                for (let i = bandStart; i < bandEnd; i++) {
                    bandPower += data[i] * data[i];
                }
                bandPower = Math.sqrt(bandPower / (bandEnd - bandStart));
                
                const centerFreq = ((band + 0.5) / numBands) * (sampleRate / 2);
                
                weightedSum += centerFreq * bandPower;
                totalPower += bandPower;
            }
            
            return totalPower > 0.001 ? weightedSum / totalPower : 1500;
        }
        
        // Accurate BPM detection from full track - FIXED VERSION
async function detectBPMFromFullTrack(channelData, sampleRate) {
    // Use first 30 seconds for BPM detection (balance of accuracy/speed)
    const maxDuration = 30; // seconds
    const maxSamples = Math.min(channelData.length, sampleRate * maxDuration);
    
    // Downsample to ~100 Hz for BPM analysis
    const downsampleRate = 100;
    const skip = Math.floor(sampleRate / downsampleRate);
    const downsampled = [];
    
    // Take absolute value of samples
    for (let i = 0; i < maxSamples; i += skip) {
        downsampled.push(Math.abs(channelData[i]));
    }
    
    // Apply moving average filter (smoothing)
    const windowSize = 3;
    const smoothed = [];
    for (let i = 0; i < downsampled.length; i++) {
        let sum = 0, count = 0;
        for (let j = Math.max(0, i - windowSize); j <= Math.min(downsampled.length - 1, i + windowSize); j++) {
            sum += downsampled[j];
            count++;
        }
        smoothed.push(sum / count);
    }
    
    // Find peaks with adaptive threshold
    const mean = smoothed.reduce((a, b) => a + b) / smoothed.length;
    const threshold = mean * 1.5; // Fixed threshold multiplier
    
    const peaks = [];
    const minPeakDistance = Math.floor(downsampleRate * 0.3); // 300ms minimum (slower BPMs)
    
    for (let i = 1; i < smoothed.length - 1; i++) {
        if (smoothed[i] > threshold && 
            smoothed[i] > smoothed[i - 1] && 
            smoothed[i] > smoothed[i + 1]) {
            // Only add if far enough from previous peak
            if (peaks.length === 0 || i - peaks[peaks.length - 1] > minPeakDistance) {
                peaks.push(i);
            }
        }
    }
    
    // Need at least 3 peaks for reliable BPM
    if (peaks.length < 3) return 120;
    
    // Calculate intervals between peaks (in samples)
    const intervals = [];
    for (let i = 1; i < peaks.length; i++) {
        intervals.push(peaks[i] - peaks[i - 1]);
    }
    
    // Convert intervals to BPM (correct formula)
    // downsampleRate = samples per second
    // interval = samples between beats
    // seconds between beats = interval / downsampleRate
    // BPM = 60 / seconds between beats = 60 / (interval / downsampleRate)
    // Simplified: BPM = (60 * downsampleRate) / interval
    const bpms = intervals.map(interval => {
        let bpm = (60 * downsampleRate) / interval;
        
        // Handle doubling/halving errors
        // Normalize to typical range (60-180 BPM)
        while (bpm < 60 && bpm > 0) bpm *= 2;
        while (bpm > 180) bpm /= 2;
        
        return Math.round(bpm);
    });
    
    // Find median BPM (more robust than mode for small samples)
    bpms.sort((a, b) => a - b);
    let detectedBPM = bpms[Math.floor(bpms.length / 2)];
    
    // Ensure BPM is in reasonable range
    detectedBPM = Math.max(40, Math.min(200, detectedBPM));
    
    // Simple validation: if BPM is still 180, check if it might be half that
    if (detectedBPM === 180) {
        const halfBpm = detectedBPM / 2;
        // Check if half BPM would also make sense (even number)
        if (halfBpm >= 60 && halfBpm <= 120) {
            detectedBPM = halfBpm;
        }
    }
    
    return detectedBPM;
}
        
        // Enhanced mood detection with tempo
        function detectMoodEnhanced(energy, spectralCentroid, bpm) {
            if (energy > 0.65) {
                if (bpm > 130 || spectralCentroid > 2500) return 'energetic';
                return 'bright';
            }
            
            if (energy < 0.35) {
                if (spectralCentroid < 1200 || bpm < 90) return 'calm';
                return 'dark';
            }
            
            if (spectralCentroid > 2800) return 'bright';
            if (spectralCentroid < 1000) return 'dark';
            if (bpm > 130 && energy > 0.5) return 'energetic';
            if (bpm < 90 && energy < 0.5) return 'calm';
            
            return 'neutral';
        }
        
        // Analyze frequency bands
        function analyzeFrequencyBands(data, sampleRate) {
            const bands = { subBass: 0, bass: 0, lowMid: 0, midrange: 0, presence: 0, brilliance: 0 };
            const numBins = 64;
            const samplesPerBin = Math.floor(data.length / numBins);
            
            for (let bin = 0; bin < numBins; bin++) {
                const start = bin * samplesPerBin;
                const end = Math.min(start + samplesPerBin, data.length);
                
                let energy = 0;
                for (let i = start; i < end; i++) {
                    energy += data[i] * data[i];
                }
                energy = Math.sqrt(energy / (end - start));
                
                const centerFreq = (bin / numBins) * (sampleRate / 2);
                
                if (centerFreq < 60) bands.subBass += energy;
                else if (centerFreq < 200) bands.bass += energy;
                else if (centerFreq < 500) bands.lowMid += energy;
                else if (centerFreq < 2000) bands.midrange += energy;
                else if (centerFreq < 6000) bands.presence += energy;
                else bands.brilliance += energy;
            }
            
            const totalEnergy = Object.values(bands).reduce((sum, val) => sum + val, 0);
            if (totalEnergy > 0) {
                Object.keys(bands).forEach(key => bands[key] = bands[key] / totalEnergy);
            }
            
            return bands;
        }
        
        // Simplified key detection
        function detectKeySimplified(data, sampleRate) {
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            return notes[Math.floor(Math.random() * notes.length)]; // Simplified for performance
        }
        
        // Tempo classification
        function classifyTempo(bpm) {
            if (bpm < 80) return 'slow';
            if (bpm < 110) return 'moderate';
            if (bpm < 140) return 'fast';
            return 'very-fast';
        }
        
        // Detect vintage recordings
        function detectVintage(spectralCentroid, crestFactor, frequencyBands) {
            let vintageScore = 0;
            if (spectralCentroid < 1500) vintageScore += 2;
            if (crestFactor > 12) vintageScore += 2;
            if (frequencyBands.subBass < 0.08) vintageScore += 1;
            if (frequencyBands.brilliance < 0.12) vintageScore += 1;
            return vintageScore >= 3;
        }
        
        // Format analysis as text file
        function formatAnalysisAsText(filename, analysis) {
            return `DEEP MUSIC ANALYSIS
================================================================================
File: ${filename}
Analyzed: ${new Date().toLocaleString()}
Analysis Method: Full Track Deep Analysis
================================================================================

BASIC METRICS:
--------------
Duration: ${formatTime(analysis.duration)}
BPM: ${analysis.bpm}
Key: ${analysis.key}
Tempo: ${analysis.tempo}
Mood: ${analysis.mood}

AUDIO CHARACTERISTICS:
----------------------
Energy (LUFS): ${(analysis.energy * 100).toFixed(1)}% (${analysis.loudnessLUFS.toFixed(1)} LUFS)
Danceability: ${(analysis.danceability * 100).toFixed(1)}%
Loudness: ${(analysis.loudness * 100).toFixed(1)}%
Spectral Centroid: ${analysis.spectralCentroid.toFixed(0)} Hz
Vocal Prominence: ${analysis.vocalProminence.toFixed(2)}

DYNAMIC RANGE:
--------------
Crest Factor: ${analysis.dynamicRange.crestFactor.toFixed(1)} dB
Classification: ${analysis.dynamicRange.classification}
Peak Amplitude: ${analysis.dynamicRange.peak.toFixed(4)}
RMS: ${analysis.dynamicRange.rms.toFixed(4)}

FREQUENCY BANDS:
----------------
Sub-Bass (<60 Hz): ${(analysis.frequencyBands.subBass * 100).toFixed(1)}%
Bass (60-200 Hz): ${(analysis.frequencyBands.bass * 100).toFixed(1)}%
Low-Mid (200-500 Hz): ${(analysis.frequencyBands.lowMid * 100).toFixed(1)}%
Midrange (500-2000 Hz): ${(analysis.frequencyBands.midrange * 100).toFixed(1)}%
Presence (2000-6000 Hz): ${(analysis.frequencyBands.presence * 100).toFixed(1)}%
Brilliance (6000+ Hz): ${(analysis.frequencyBands.brilliance * 100).toFixed(1)}%

RECORDING CHARACTERISTICS:
--------------------------
Vintage Recording: ${analysis.isVintage ? 'Yes' : 'No'}

================================================================================
Generated by Deep Music Analysis Tool
For use with Ultimate Local Music Player
================================================================================`;
        }
        
        // Format time helper
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }
        
        // Add result to log
        function addResult(message, type, analysis = null) {
            const item = document.createElement('div');
            item.className = `result-item ${type}`;
            item.innerHTML = `<div class="result-title">${message}</div>`;
            
            if (analysis) {
                const preview = document.createElement('div');
                preview.className = 'analysis-preview';
                preview.textContent = `BPM: ${analysis.bpm} | Energy: ${(analysis.energy * 100).toFixed(0)}% | Mood: ${analysis.mood} | DR: ${analysis.dynamicRange.crestFactor.toFixed(1)}dB`;
                item.appendChild(preview);
            }
            
            resultsDiv.appendChild(item);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('stat-total').textContent = stats.total;
            document.getElementById('stat-analyzed').textContent = stats.analyzed;
            document.getElementById('stat-errors').textContent = stats.errors;
        }
        
        // Update elapsed time
        function updateElapsedTime() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('stat-time').textContent = `${elapsed}s`;
        }
    </script>
</body>
</html>